<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机笔记 on 夏田墨计算机笔记</title><link>https://javioustlj.github.io/cs-note/</link><description>Recent content in 计算机笔记 on 夏田墨计算机笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://javioustlj.github.io/cs-note/index.xml" rel="self" type="application/rss+xml"/><item><title>concepts</title><link>https://javioustlj.github.io/cs-note/ai/nccl/concenpts/</link><pubDate>Fri, 14 Feb 2025 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/nccl/concenpts/</guid><description>concepts node: 一个服务器 CUDA device：一个GPU rank: GPU的编号 communicator: 这是一个抽象的概念，用于管理一组GPU之间的通信。 IB GDA temp full-blown
multi-GPU parallelization model:
single-threaded control of all GPUs multi-threaded, for example, using one thread per GPU multi-process, for example, MPI SHARP
NVLink Sharp IB Sharp Algorithm
NVLS IB Sharp</description></item><item><title>cpp17</title><link>https://javioustlj.github.io/cs-note/cpp/cpp17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/cpp/cpp17/</guid><description>嵌套命名空间； Nested Namespaces If 和 switch 中的变量声明；Variable declaration in if and switch； If constexpr 语句 结构化绑定 折叠表达式 枚举的直接列表初始化 内联变量 constexpr lambda 表达式 新增三个 attributes 1. Nested Namespaces 嵌套命名空间 C++17 之前
namespace Game { namespace Graphics { namespace Physics { class 2D { .......... }; } // Physics } // Graphics } // Game C++17 之后
namespace Game::Graphics::Physics { class 2D { .......... }; } 2. Variable declaration in if and switch C++17 之前</description></item><item><title>overview</title><link>https://javioustlj.github.io/cs-note/ai/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/overview/</guid><description>AI (Artificial Intelligence) 涉及到很多的方面，让我们一层一层拨开它神秘的面纱。</description></item><item><title>overview</title><link>https://javioustlj.github.io/cs-note/linux/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/linux/overview/</guid><description>Linux 内核主要由进程管理、内存管理、设备驱动、文件系统、网络协议栈、系统调用组成。
#linux ## 进程管理 ## 内存管理 ## 设备驱动 ## 文件系统 ## 网络协议栈 ## 系统调用</description></item><item><title>二项树</title><link>https://javioustlj.github.io/cs-note/dsa/binomial_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/dsa/binomial_tree/</guid><description>1. 二项树的定义 一般，采用递归的形式来定义二项树。
我们假定$B_k$代表第$k$颗二项树，也成为第k阶二项树：
$B_0$ 是一颗只有一个节点的树。 对于$k \geq 1$， $B_k$ 是通过将两颗$B_{k-1}$树链接起来形成的，其中一颗$B_{k-1}$树的跟节点成为另一颗$B_{k-1}$树的最左子节点。 2. 二项树的性质 节点数：二项树$B_k$的节点数为$2^k$。
高度：二项树$B_k$的高度为$k+1$。
度数：二项树$B_k$的根节点的度数为$k$，且树中每个节点的度数都不超过$k$。
节点深度：深度为$d$的节点数为$C^d_k$, 其中$C^d_k$是组合数，表示从$k$个不同元素中选取出$d$个元素的组合数。
从左往右，根的第i个子节点是一颗阶为$k-i$的二项树
3. Reference https://rkgiitbh.github.io/data-structures.github.io/HTML/binomialTrees.html https://en.wikipedia.org/wiki/Binomial_heap</description></item><item><title>abbr</title><link>https://javioustlj.github.io/cs-note/ai/nccl/abbr/</link><pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/nccl/abbr/</guid><description> abbr english chinese mark SHARP Scalable Hierarchical Aggregation and Reduction Protocol CUDA Compute Unified Device Architecture NVLS NVLink Sharp IB InfiniBand SM Streaming Multiprocessor VMM Virtual Memory Management RAS Reliability, availability, Serviceability NIC Network Interface Card RDMA Remote Direct Memory Access GDRDMA GPU Direct RDMA DMA Direct Memory Access ACS Access Control Services IOMMU IO Memory Management Unit PLX ATS Address Translation Services RoCE RDMA over Converged Ethernet abbr english chinese mark NVTX NVIDIA Tools Extension</description></item><item><title>awesome-cs</title><link>https://javioustlj.github.io/cs-note/blog/2025/02/16/awesome-cs/</link><pubDate>Sun, 16 Feb 2025 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2025/02/16/awesome-cs/</guid><description>Linux下C++编程 Linux环境编程：从应用到内核 Linux高性能服务器编程</description></item><item><title>cpp类内存布局</title><link>https://javioustlj.github.io/cs-note/blog/2024/04/16/cpp%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link><pubDate>Tue, 16 Apr 2024 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2024/04/16/cpp%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid><description>没有虚函数的情况 #include &amp;lt;iostream&amp;gt; class A { public: A() : c(0) { std::cout &amp;lt;&amp;lt; &amp;#34;A::A()&amp;#34; &amp;lt;&amp;lt; std::endl; func2(); }; void func2() { std::cout &amp;lt;&amp;lt;&amp;#34;A::func2()&amp;#34; &amp;lt;&amp;lt; std::endl; }; private: int c; }; int main(void) { A a1; A a2; return 0; } GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1 Copyright (C) 2022 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt; This is free software: you are free to change and redistribute it.</description></item><item><title>gdb常用命令总结</title><link>https://javioustlj.github.io/cs-note/blog/2024/04/05/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 05 Apr 2024 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2024/04/05/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid><description>1. cheat sheet 显示类命令 缩写 命令说明 info i 查看断点 / 线程等信息 print p 打印变量或寄存器值 display display 自动显示命令 whatis whatis 查看变量类型 ptype ptype 查看变量类型 list l 显示源码 disassemble dis 查看汇编代码 backtrace bt 查看当前线程的调用堆栈 help help 帮助命令 控制类型的命令 缩写 命令说明 run r 运行一个待调试的程序 continue c 让暂停的程序继续运行 next n 运行到下一行 step s 单步执行，遇到函数会进入 until u 运行到指定行停下来 finish fi 结束当前调用函数，回到上一层调用函数处 return return 结束当前调用函数并返回指定值，到上一层函数调用处 jump j 将当前程序执行流跳转到指定行或地址 断点监视点 缩写 命令说明 break b 添加断点 tbreak tb 添加临时断点 delete d 删除断点 enable enable 启用某个断点 disable disable 禁用某个断点 watch watch 监视某一个变量或内存地址的值是否发生变化 名称 缩写 命令说明 frame f 切换到当前调用线程的指定堆栈 thread thread 切换到指定线程 set args set args 设置程序启动命令行参数 show args show args 查看设置的命令行参数 1.</description></item><item><title>一个奇怪问题的debug之旅</title><link>https://javioustlj.github.io/cs-note/blog/2024/04/05/%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84debug%E4%B9%8B%E6%97%85/</link><pubDate>Fri, 05 Apr 2024 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2024/04/05/%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84debug%E4%B9%8B%E6%97%85/</guid><description>问题 公司的守护进程的优雅关闭，是通过捕获 SIGTERM 实现的：
捕获 SIGTERM 退出处理（释放资源等等） 最后调用 pthread_exit 退出 出现的问题是：优雅关闭时，进程又收到了 SIGABRT ，导致进程又被异常杀死了，最后进程并没有优雅的关闭。
当然在公司定位这个问题的过程中，都是通过日志和 gdb 工具来进行的。
现在我们模拟一下解决这个问题的过程，为了方便起见，就使用打印和 gdb 来进行debug
模拟的问题代码如下：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;signal.h&amp;gt; void printSigInfo(int signo, siginfo_t* info, void* context) { std::cout &amp;lt;&amp;lt; &amp;#34;Signal Info:&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_signo: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_signo &amp;lt;&amp;lt; &amp;#34; - Signal number&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_code: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_code &amp;lt;&amp;lt; &amp;#34; - Signal code&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_errno: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_errno &amp;lt;&amp;lt; &amp;#34; - Errno value associated with signal&amp;#34; &amp;lt;&amp;lt; std::endl; if (info-&amp;gt;si_code &amp;gt; 0 &amp;amp;&amp;amp; info-&amp;gt;si_code &amp;lt; NSIG) { // 可能需要针对具体情况进行检查 std::cout &amp;lt;&amp;lt; &amp;#34; si_pid: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_pid &amp;lt;&amp;lt; &amp;#34; - Sending process ID&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_uid: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_uid &amp;lt;&amp;lt; &amp;#34; - Real user ID of sending process&amp;#34; &amp;lt;&amp;lt; std::endl; if (info-&amp;gt;si_addr) { std::cout &amp;lt;&amp;lt; &amp;#34; si_addr: &amp;#34; &amp;lt;&amp;lt; static_cast&amp;lt;void*&amp;gt;(info-&amp;gt;si_addr) &amp;lt;&amp;lt; &amp;#34; - Faulting address&amp;#34; &amp;lt;&amp;lt; std::endl; } } } void LinuxSigHandler(int signo, siginfo_t* info, void* context) { switch (signo) { case SIGABRT: std::cout &amp;lt;&amp;lt; &amp;#34;Caught signal SIGABRT (&amp;#34; &amp;lt;&amp;lt; signo &amp;lt;&amp;lt; &amp;#34;).</description></item><item><title/><link>https://javioustlj.github.io/cs-note/ai/nccl/bootstrapnetinit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/nccl/bootstrapnetinit/</guid><description>bootstrapNetInit 作用：找到可用的网络接口，并将它的信息保存下来。
如果配置了NCCL_COMM_ID，则使用和它在同一网段的网口。 ib 网络接口 普通网口 docker 网口 loopback 网口</description></item><item><title/><link>https://javioustlj.github.io/cs-note/ai/nccl/init/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/nccl/init/</guid><description>ncclCommInitAll ncclGetUniqueId ncclInit initEnv initGdrCopy bootstrapNetInit initNvtxRegisteredEnums bootstrapGetUniqueId 64位的随机数 + bootstrap网络接口地址
bootstrapCreateRoot ncclSocketInit 创建TCP socket ncclCommInitRankDev NCCLCHECKGOTO(ncclGroupStartInternal(), ret, fail); for (int i=0; i&amp;lt;ndev; i++) { // Ignore return codes .. we need to call ncclGroupEnd to clean up anyway int dev = devlist ? devlist[i] : i; CUDACHECKGOTO(cudaSetDevice(dev), ret, fail); ncclCommInitRankDev(comms+i, ndev,1, &amp;amp;uniqueId, i, dev, &amp;amp;config, __func__); }</description></item><item><title/><link>https://javioustlj.github.io/cs-note/ai/nccl/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/nccl/introduction/</guid><description>网络 nccl所需要两个网络，一个是bootstrap网络，一个是数据通信网络。 bootstrap网络主要用于初始化时交换一些简单的信息，如果每个机器的ip端口，由于数据量较小，而且只在初始化阶段执行一次，因此bootstrap使用的是tcp 而通信网络是用于实际数据的传输，因此优先使用RDMA（支持GDR的话会优先GDR）</description></item><item><title/><link>https://javioustlj.github.io/cs-note/ai/nccl/term/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/nccl/term/</guid><description>PCIe（高速串行总线） PCIe是一种连接扩展设备的高速串行总线标准。它是一种内部接口，用于连接主板（类似于购物中心）和各种插槽（类似于商店）上的扩展设备，如显卡、网卡、硬盘控制器和其他周边设备。PCIe提供了快速而可靠的数据传输通道，允许扩展设备与计算机系统进行高速通信。可以实现几十GB/S的传输速度
NVlink（NVIDIA的高速互连技术） NVLink是一种由NVIDIA开发的高速互连技术，用于在计算机系统中连接多个图形处理单元（GPU），以实现更高的数据传输速度和更低的延迟。能够提供比PCIe更快的传输速度，可通过桥接器连接两块NVIDIA显卡，实现上百GB/S的传输速度
Infiniband（无限带宽） InfiniBand（无限带宽）是一种高性能、低延迟的计算和存储网络架构和通信协议。 InfiniBand被广泛应用于高性能计算（HPC）领域和大规模数据中心，它提供了高带宽和低延迟的数据传输能力，适用于处理大规模并行计算、高速数据存储和集群应用。带宽可以达到400GB/S
MPI（并行计算Message Passing Interface） MPI (Message Passing Interface) 是一种用于编写并行程序的通信协议和标准。它提供了一套函数接口，使得在多个计算节点（通常是集群或超级计算机）上的多个进程之间进行消息传递和通信成为可能，从而实现并行计算。MPI主要用于解决并行计算中的通信和同步问题。它允许开发人员将一个问题分解为多个并行的任务，每个任务都在不同的计算节点上执行，通过消息传递来共享数据和结果
Pinned (page-locked) memory</description></item><item><title/><link>https://javioustlj.github.io/cs-note/blog/1/01/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/1/01/01/</guid><description>abbr english chinese DP Debug Port 调试端口 MMU Memory Management Unit 内存管理单元 EXI External Interface 外部接口 XIF Crossbar Interface 交叉开关接口 TM Traffic Manager 流量管理器 TM OQ Traffic Manager Output Queue 流量管理器输出队列 TM POL Traffic Manager Policy 流量管理器策略 TM SCH Traffic Manager Scheduler 流量管理器调度器 PSTAT Port Status 端口状态 ETH Ethernet 以太网 ETH MAC Ethernet Media Access Control 以太网介质访问控制 ETH PCS Ethernet Physical Coding Sublayer 以太网物理编码子层 ETH ADAPT Ethernet Adaptation 以太网适配 RND Random intr interrupt 中断 ECC Error Correcting Code 纠错码 SRAM Static Random Access Memory 静态随机存取存储器 DRAM Dynamic Random Access Memory 动态随机存取存储器 int ioctl(int fd, unsigned long op, .</description></item><item><title/><link>https://javioustlj.github.io/cs-note/blog/1/01/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/1/01/01/</guid><description>RAII</description></item><item><title>Search Results</title><link>https://javioustlj.github.io/cs-note/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/search/</guid><description/></item><item><title>关于夏田墨计算机笔记</title><link>https://javioustlj.github.io/cs-note/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/about/</guid><description> 夏田墨计算机笔记 计算机笔记 在工作中遇到了很多的计算机知识，一直没有做过一个整理，趁着这次换工作的机会，把整理的内容记录下来.
这个博客用来记录总结的知识，以及面试的过程。
夏田墨计算机笔记 夏田墨计算机笔记</description></item></channel></rss>