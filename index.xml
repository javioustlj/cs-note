<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>计算机笔记 on 夏田墨计算机笔记</title><link>https://javioustlj.github.io/cs-note/</link><description>Recent content in 计算机笔记 on 夏田墨计算机笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://javioustlj.github.io/cs-note/index.xml" rel="self" type="application/rss+xml"/><item><title>cpp17</title><link>https://javioustlj.github.io/cs-note/cpp/cpp17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/cpp/cpp17/</guid><description>嵌套命名空间； Nested Namespaces If 和 switch 中的变量声明；Variable declaration in if and switch； If constexpr 语句 结构化绑定 折叠表达式 枚举的直接列表初始化 内联变量 constexpr lambda 表达式 新增三个 attributes 1. Nested Namespaces 嵌套命名空间 C++17 之前
namespace Game { namespace Graphics { namespace Physics { class 2D { .......... }; } // Physics } // Graphics } // Game C++17 之后
namespace Game::Graphics::Physics { class 2D { .......... }; } 2. Variable declaration in if and switch C++17 之前</description></item><item><title>overview</title><link>https://javioustlj.github.io/cs-note/ai/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/ai/overview/</guid><description>AI (Artificial Intelligence) 涉及到很多的方面，让我们一层一层拨开它神秘的面纱。</description></item><item><title>overview</title><link>https://javioustlj.github.io/cs-note/linux/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/linux/overview/</guid><description>Linux 内核主要由进程管理、内存管理、设备驱动、文件系统、网络协议栈、系统调用组成。
#linux ## 进程管理 ## 内存管理 ## 设备驱动 ## 文件系统 ## 网络协议栈 ## 系统调用</description></item><item><title>二项树</title><link>https://javioustlj.github.io/cs-note/dsa/binomial_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/dsa/binomial_tree/</guid><description>1. 二项树的定义 一般，采用递归的形式来定义二项树。
我们假定$B_k$代表第$k$颗二项树，也成为第k阶二项树：
$B_0$ 是一颗只有一个节点的树。 对于$k \geq 1$， $B_k$ 是通过将两颗$B_{k-1}$树链接起来形成的，其中一颗$B_{k-1}$树的跟节点成为另一颗$B_{k-1}$树的最左子节点。 2. 二项树的性质 节点数：二项树$B_k$的节点数为$2^k$。
高度：二项树$B_k$的高度为$k+1$。
度数：二项树$B_k$的根节点的度数为$k$，且树中每个节点的度数都不超过$k$。
节点深度：深度为$d$的节点数为$C^d_k$, 其中$C^d_k$是组合数，表示从$k$个不同元素中选取出$d$个元素的组合数。
从左往右，根的第i个子节点是一颗阶为$k-i$的二项树
3. Reference https://rkgiitbh.github.io/data-structures.github.io/HTML/binomialTrees.html https://en.wikipedia.org/wiki/Binomial_heap</description></item><item><title>awesome-cs</title><link>https://javioustlj.github.io/cs-note/blog/2025/02/16/awesome-cs/</link><pubDate>Sun, 16 Feb 2025 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2025/02/16/awesome-cs/</guid><description>Linux下C++编程 Linux环境编程：从应用到内核 Linux高性能服务器编程</description></item><item><title>cpp类内存布局</title><link>https://javioustlj.github.io/cs-note/blog/2024/04/16/cpp%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</link><pubDate>Tue, 16 Apr 2024 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2024/04/16/cpp%E7%B1%BB%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</guid><description>没有虚函数的情况 #include &amp;lt;iostream&amp;gt; class A { public: A() : c(0) { std::cout &amp;lt;&amp;lt; &amp;#34;A::A()&amp;#34; &amp;lt;&amp;lt; std::endl; func2(); }; void func2() { std::cout &amp;lt;&amp;lt;&amp;#34;A::func2()&amp;#34; &amp;lt;&amp;lt; std::endl; }; private: int c; }; int main(void) { A a1; A a2; return 0; } GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1 Copyright (C) 2022 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt; This is free software: you are free to change and redistribute it.</description></item><item><title>gdb常用命令总结</title><link>https://javioustlj.github.io/cs-note/blog/2024/04/05/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 05 Apr 2024 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2024/04/05/gdb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid><description>1. cheat sheet 显示类命令 缩写 命令说明 info i 查看断点 / 线程等信息 print p 打印变量或寄存器值 display display 自动显示命令 whatis whatis 查看变量类型 ptype ptype 查看变量类型 list l 显示源码 disassemble dis 查看汇编代码 backtrace bt 查看当前线程的调用堆栈 help help 帮助命令 控制类型的命令 缩写 命令说明 run r 运行一个待调试的程序 continue c 让暂停的程序继续运行 next n 运行到下一行 step s 单步执行，遇到函数会进入 until u 运行到指定行停下来 finish fi 结束当前调用函数，回到上一层调用函数处 return return 结束当前调用函数并返回指定值，到上一层函数调用处 jump j 将当前程序执行流跳转到指定行或地址 断点监视点 缩写 命令说明 break b 添加断点 tbreak tb 添加临时断点 delete d 删除断点 enable enable 启用某个断点 disable disable 禁用某个断点 watch watch 监视某一个变量或内存地址的值是否发生变化 名称 缩写 命令说明 frame f 切换到当前调用线程的指定堆栈 thread thread 切换到指定线程 set args set args 设置程序启动命令行参数 show args show args 查看设置的命令行参数 1.</description></item><item><title>一个奇怪问题的debug之旅</title><link>https://javioustlj.github.io/cs-note/blog/2024/04/05/%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84debug%E4%B9%8B%E6%97%85/</link><pubDate>Fri, 05 Apr 2024 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/2024/04/05/%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84debug%E4%B9%8B%E6%97%85/</guid><description>问题 公司的守护进程的优雅关闭，是通过捕获 SIGTERM 实现的：
捕获 SIGTERM 退出处理（释放资源等等） 最后调用 pthread_exit 退出 出现的问题是：优雅关闭时，进程又收到了 SIGABRT ，导致进程又被异常杀死了，最后进程并没有优雅的关闭。
当然在公司定位这个问题的过程中，都是通过日志和 gdb 工具来进行的。
现在我们模拟一下解决这个问题的过程，为了方便起见，就使用打印和 gdb 来进行debug
模拟的问题代码如下：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;signal.h&amp;gt; void printSigInfo(int signo, siginfo_t* info, void* context) { std::cout &amp;lt;&amp;lt; &amp;#34;Signal Info:&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_signo: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_signo &amp;lt;&amp;lt; &amp;#34; - Signal number&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_code: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_code &amp;lt;&amp;lt; &amp;#34; - Signal code&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_errno: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_errno &amp;lt;&amp;lt; &amp;#34; - Errno value associated with signal&amp;#34; &amp;lt;&amp;lt; std::endl; if (info-&amp;gt;si_code &amp;gt; 0 &amp;amp;&amp;amp; info-&amp;gt;si_code &amp;lt; NSIG) { // 可能需要针对具体情况进行检查 std::cout &amp;lt;&amp;lt; &amp;#34; si_pid: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_pid &amp;lt;&amp;lt; &amp;#34; - Sending process ID&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34; si_uid: &amp;#34; &amp;lt;&amp;lt; info-&amp;gt;si_uid &amp;lt;&amp;lt; &amp;#34; - Real user ID of sending process&amp;#34; &amp;lt;&amp;lt; std::endl; if (info-&amp;gt;si_addr) { std::cout &amp;lt;&amp;lt; &amp;#34; si_addr: &amp;#34; &amp;lt;&amp;lt; static_cast&amp;lt;void*&amp;gt;(info-&amp;gt;si_addr) &amp;lt;&amp;lt; &amp;#34; - Faulting address&amp;#34; &amp;lt;&amp;lt; std::endl; } } } void LinuxSigHandler(int signo, siginfo_t* info, void* context) { switch (signo) { case SIGABRT: std::cout &amp;lt;&amp;lt; &amp;#34;Caught signal SIGABRT (&amp;#34; &amp;lt;&amp;lt; signo &amp;lt;&amp;lt; &amp;#34;).</description></item><item><title/><link>https://javioustlj.github.io/cs-note/blog/1/01/01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/blog/1/01/01/</guid><description>abbr english chinese DP Debug Port 调试端口 MMU Memory Management Unit 内存管理单元 EXI External Interface 外部接口 XIF Crossbar Interface 交叉开关接口 TM Traffic Manager 流量管理器 TM OQ Traffic Manager Output Queue 流量管理器输出队列 TM POL Traffic Manager Policy 流量管理器策略 TM SCH Traffic Manager Scheduler 流量管理器调度器 PSTAT Port Status 端口状态 ETH Ethernet 以太网 ETH MAC Ethernet Media Access Control 以太网介质访问控制 ETH PCS Ethernet Physical Coding Sublayer 以太网物理编码子层 ETH ADAPT Ethernet Adaptation 以太网适配 RND Random intr interrupt 中断 ECC Error Correcting Code 纠错码 SRAM Static Random Access Memory 静态随机存取存储器 DRAM Dynamic Random Access Memory 动态随机存取存储器 int ioctl(int fd, unsigned long op, .</description></item><item><title>Search Results</title><link>https://javioustlj.github.io/cs-note/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/search/</guid><description/></item><item><title>关于夏田墨计算机笔记</title><link>https://javioustlj.github.io/cs-note/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://javioustlj.github.io/cs-note/about/</guid><description> 夏田墨计算机笔记 计算机笔记 在工作中遇到了很多的计算机知识，一直没有做过一个整理，趁着这次换工作的机会，把整理的内容记录下来.
这个博客用来记录总结的知识，以及面试的过程。
夏田墨计算机笔记 夏田墨计算机笔记</description></item></channel></rss>